"use strict";

var warp10Finalize = require("warp10/finalize");
var eventDelegation = require("../event-delegation");
var win = window;
var createFragmentNode =
require("../../vdom/morphdom/fragment").ap_;
var componentsUtil = require("../util");
var componentLookup = componentsUtil.D_;
var addComponentRootToKeyedElements =
componentsUtil.aq_;
var ComponentDef = require("../ComponentDef");
var registry = require("../registry");
var domData = require("../dom-data");
var keyedElementsByComponentId = domData.G_;
var componentsByDOMNode = domData.F_;
var serverComponentRootNodes = {};
var serverRenderedMeta = {};

var DEFAULT_RUNTIME_ID = "M";
var FLAG_WILL_RERENDER_IN_BROWSER = 1;
// var FLAG_HAS_RENDER_BODY = 2;

var deferredDefs;

function indexServerComponentBoundaries(node, runtimeId, stack) {
  var componentId;
  var ownerId;
  var ownerComponent;
  var keyedElements;
  var nextSibling;
  var runtimeLength = runtimeId.length;
  stack = stack || [];

  node = node.firstChild;
  while (node) {
    nextSibling = node.nextSibling;
    if (node.nodeType === 8) {
      // Comment node
      var commentValue = node.nodeValue;
      if (commentValue.slice(0, runtimeLength) === runtimeId) {
        var firstChar = commentValue[runtimeLength];

        if (firstChar === "^" || firstChar === "#") {
          stack.push(node);
        } else if (firstChar === "/") {
          var endNode = node;
          var startNode = stack.pop();
          var rootNode;

          if (startNode.parentNode === endNode.parentNode) {
            rootNode = createFragmentNode(startNode.nextSibling, endNode);
          } else {
            rootNode = createFragmentNode(
            endNode.parentNode.firstChild,
            endNode);

          }

          componentId = startNode.nodeValue.substring(runtimeLength + 1);
          firstChar = startNode.nodeValue[runtimeLength];

          if (firstChar === "^") {
            var parts = componentId.split(/ /g);
            var key = parts[2];
            ownerId = parts[1];
            componentId = parts[0];
            if (ownerComponent = componentLookup[ownerId]) {
              keyedElements = ownerComponent.k_;
            } else {
              keyedElements =
              keyedElementsByComponentId[ownerId] || (
              keyedElementsByComponentId[ownerId] = {});
            }
            addComponentRootToKeyedElements(
            keyedElements,
            key,
            rootNode,
            componentId);

          }

          serverComponentRootNodes[componentId] = rootNode;

          startNode.parentNode.removeChild(startNode);
          endNode.parentNode.removeChild(endNode);
        }
      }
    } else if (node.nodeType === 1) {
      // HTML element node
      var markoKey = node.getAttribute("data-marko-key");
      var markoProps = componentsUtil.an_(node);
      if (markoKey) {
        var separatorIndex = markoKey.indexOf(" ");
        ownerId = markoKey.substring(separatorIndex + 1);
        markoKey = markoKey.substring(0, separatorIndex);
        if (ownerComponent = componentLookup[ownerId]) {
          keyedElements = ownerComponent.k_;
        } else {
          keyedElements =
          keyedElementsByComponentId[ownerId] || (
          keyedElementsByComponentId[ownerId] = {});
        }
        keyedElements[markoKey] = node;
      }
      if (markoProps) {
        Object.keys(markoProps).forEach(function (key) {
          if (key.slice(0, 2) === "on") {
            eventDelegation._E_(key.slice(2));
          }
        });
      }
      indexServerComponentBoundaries(node, runtimeId, stack);
    }

    node = nextSibling;
  }
}

function invokeComponentEventHandler(component, targetMethodName, args) {
  var method = component[targetMethodName];
  if (!method) {
    throw Error("Method not found: " + targetMethodName);
  }

  method.apply(component, args);
}

function addEventListenerHelper(el, eventType, isOnce, listener) {
  var eventListener = listener;
  if (isOnce) {
    eventListener = function (event) {
      listener(event);
      el.removeEventListener(eventType, eventListener);
    };
  }

  el.addEventListener(eventType, eventListener, false);

  return function remove() {
    el.removeEventListener(eventType, eventListener);
  };
}

function addDOMEventListeners(
component,
el,
eventType,
targetMethodName,
isOnce,
extraArgs,
handles)
{
  var removeListener = addEventListenerHelper(
  el,
  eventType,
  isOnce,
  function (event) {
    var args = [event, el];
    if (extraArgs) {
      args = extraArgs.concat(args);
    }

    invokeComponentEventHandler(component, targetMethodName, args);
  });

  handles.push(removeListener);
}

function initComponent(componentDef, host) {
  var component = componentDef.h_;

  component.J_();
  component.Y_ = host;

  var isExisting = componentDef._H_;

  if (isExisting) {
    component._c_();
  }

  var domEvents = componentDef._G_;
  if (domEvents) {
    var eventListenerHandles = [];

    domEvents.forEach(function (domEventArgs) {
      // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)

      var eventType = domEventArgs[0];
      var targetMethodName = domEventArgs[1];
      var eventEl = component.k_[domEventArgs[2]];
      var isOnce = domEventArgs[3];
      var extraArgs = domEventArgs[4];

      addDOMEventListeners(
      component,
      eventEl,
      eventType,
      targetMethodName,
      isOnce,
      extraArgs,
      eventListenerHandles);

    });

    if (eventListenerHandles.length) {
      component.N_ = eventListenerHandles;
    }
  }

  if (component.S_) {
    component.I_();
  } else {
    component.S_ = true;
    component._A_();
  }
}

/**
 * This method is used to initialized components associated with UI components
 * rendered in the browser. While rendering UI components a "components context"
 * is added to the rendering context to keep up with which components are rendered.
 * When ready, the components can then be initialized by walking the component tree
 * in the components context (nested components are initialized before ancestor components).
 * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances
 */
function initClientRendered(componentDefs, host) {
  if (!host) host = document;
  // Ensure that event handlers to handle delegating events are
  // always attached before initializing any components
  eventDelegation.ao_(host);
  var len = componentDefs.length;
  var componentDef;
  var i;

  for (i = len; i--;) {
    componentDef = componentDefs[i];
    trackComponent(componentDef);
  }

  for (i = len; i--;) {
    componentDef = componentDefs[i];
    initComponent(componentDef, host);
  }
}

/**
 * This method initializes all components that were rendered on the server by iterating over all
 * of the component IDs.
 */
function initServerRendered(renderedComponents, host) {
  var type = typeof renderedComponents;
  var globalKey = "$";
  var runtimeId;

  if (type !== "object") {
    if (type === "string") {
      runtimeId = renderedComponents;
      globalKey += runtimeId + "_C";
    } else {
      globalKey += (runtimeId = DEFAULT_RUNTIME_ID) + "C";
    }

    renderedComponents = win[globalKey];

    // eslint-disable-next-line no-constant-condition












    var fakeArray = win[globalKey] = {
      r: runtimeId,
      concat: initServerRendered };


    // eslint-disable-next-line no-constant-condition




    if (renderedComponents && renderedComponents.forEach) {
      renderedComponents.forEach(function (renderedComponent) {
        fakeArray.concat(renderedComponent);
      });
    }

    return fakeArray;
  }

  var isFromSerializedGlobals = this.concat === initServerRendered;
  renderedComponents = warp10Finalize(renderedComponents);

  if (isFromSerializedGlobals) {
    runtimeId = this.r;
    host = document;
  } else {
    runtimeId = renderedComponents.r || DEFAULT_RUNTIME_ID;
    if (!host) host = document;

    // eslint-disable-next-line no-constant-condition





  }

  // eslint-disable-next-line no-constant-condition








  var prefix = renderedComponents.p || "";
  var meta = serverRenderedMeta[prefix];
  var isLast = renderedComponents.l;

  if (meta) {
    if (isLast) {
      delete serverRenderedMeta[prefix];
    }
  } else {
    meta = {};

    if (!isLast) {
      serverRenderedMeta[prefix] = meta;
    }
  }

  // Ensure that event handlers to handle delegating events are
  // always attached before initializing any components
  indexServerComponentBoundaries(host, runtimeId);
  eventDelegation.ao_(host);

  if (renderedComponents.g) {
    meta.ar_ = renderedComponents.g;
  }

  if (renderedComponents.t) {
    meta.as_ = meta.as_ ?
    meta.as_.concat(renderedComponents.t) :
    renderedComponents.t;
  }

  // hydrate components top down (leaf nodes last)
  // and return an array of functions to mount these components
  (renderedComponents.w || []).
  map(function (componentDef) {
    var typeName = meta.as_[componentDef[1]];

    return registry.at_(typeName) ?
    tryHydrateComponent(componentDef, meta, host, runtimeId) :
    registry.au_(
    componentDef,
    typeName,
    meta,
    host,
    runtimeId);

  }).
  reverse().
  forEach(tryInvoke);

  return this;
}

function tryHydrateComponent(rawDef, meta, host, runtimeId) {
  var componentDef = ComponentDef._P_(
  rawDef,
  meta.as_,
  meta.ar_,
  registry);

  var mount = hydrateComponentAndGetMount(componentDef, host);

  if (!mount) {
    // hydrateComponentAndGetMount will return false if there is not rootNode
    // for the component.  If this is the case, we'll wait until the
    // DOM has fully loaded to attempt to init the component again.
    if (deferredDefs) {
      deferredDefs.push(componentDef);
    } else {
      deferredDefs = [componentDef];
      document.addEventListener("DOMContentLoaded", function () {
        indexServerComponentBoundaries(host, runtimeId);
        deferredDefs.
        map(function (componentDef) {
          return hydrateComponentAndGetMount(componentDef, host);
        }).
        reverse().
        forEach(tryInvoke);
        deferredDefs = undefined;
      });
    }
  }

  return mount;
}

function hydrateComponentAndGetMount(componentDef, host) {
  var componentId = componentDef.id;
  var component = componentDef.h_;
  var rootNode = serverComponentRootNodes[componentId];
  var renderResult;

  if (rootNode) {
    delete serverComponentRootNodes[componentId];

    component.L_ = rootNode;
    componentsByDOMNode.set(rootNode, component);

    if (componentDef._J_ & FLAG_WILL_RERENDER_IN_BROWSER) {
      component.Y_ = host;
      renderResult = component._q_(component.R_, true);
      trackComponent(componentDef);
      return function mount() {
        renderResult.afterInsert(host);
      };
    } else {
      trackComponent(componentDef);
    }

    return function mount() {
      initComponent(componentDef, host);
    };
  }
}

function trackComponent(componentDef) {
  var component = componentDef.h_;
  if (component) {
    componentLookup[component.id] = component;
  }
}

function tryInvoke(fn) {
  if (fn) fn();
}

exports._S_ = initClientRendered;
exports.aj_ = initServerRendered;
exports.av_ = tryHydrateComponent;