"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.findAttributeTags = findAttributeTags;exports.findParentTag = findParentTag;exports.getArgOrSequence = getArgOrSequence;exports.getFullyResolvedTagName = getFullyResolvedTagName;exports.getMacroIdentifier = getMacroIdentifier;exports.getTagDef = getTagDef;exports.getTemplateId = getTemplateId;exports.isAttributeTag = isAttributeTag;exports.isDynamicTag = isDynamicTag;exports.isLoopTag = isLoopTag;exports.isMacroTag = isMacroTag;exports.isNativeTag = isNativeTag;exports.isTransparentTag = isTransparentTag;exports.loadFileForImport = loadFileForImport;exports.loadFileForTag = loadFileForTag;exports.resolveTagImport = resolveTagImport;var _path = require("path");
var _resolveFrom = _interopRequireDefault(require("resolve-from"));
var _crypto = require("crypto");
var _compiler = require("@marko/compiler");
var _lassoPackageRoot = require("lasso-package-root");
var _taglib = require("./taglib");
var _imports = require("./imports");
const TRANSPARENT_TAGS = new Set([
"for",
"while",
"if",
"else",
"else-if",
"_no-update"]);


const CWD = process.cwd();
let ROOT = CWD;
try {
  ROOT = (0, _lassoPackageRoot.getRootDir)(ROOT) || ROOT;
  // eslint-disable-next-line no-empty
} catch {}

function isNativeTag(path) {
  if (path.node._isDynamicString) {
    return true;
  }

  const tagDef = getTagDef(path);
  return (
    tagDef &&
    tagDef.html && (
    tagDef.htmlType === "custom-element" ||
    !tagDef.template && !tagDef.renderer));

}

function isDynamicTag(path) {
  return !_compiler.types.isStringLiteral(path.node.name);
}

function isAttributeTag(path) {
  const {
    node: { name } } =
  path;
  return _compiler.types.isStringLiteral(name) && name.value[0] === "@";
}

function isTransparentTag(path) {
  const {
    node: { name } } =
  path;
  return _compiler.types.isStringLiteral(name) && TRANSPARENT_TAGS.has(name.value);
}

function isMacroTag(path) {
  return Boolean(getMacroIdentifier(path));
}

function getMacroIdentifier(path) {
  const macros = path.hub.file.metadata.marko.macros;
  const { name } = path.node;

  if (_compiler.types.isStringLiteral(name)) {
    const id = macros[name.value];

    if (id) {
      return _compiler.types.identifier(id);
    }
  }
}

function getTagDef(path) {
  const {
    node,
    hub: { file } } =
  path;

  if (!node.tagDef) {
    if (isDynamicTag(path) || isMacroTag(path)) {
      node.tagDef = null;
    } else {
      node.tagDef =
      (0, _taglib.getTagDefForTagName)(
      file,
      isAttributeTag(path) ? getFullyResolvedTagName(path) : node.name.value) ||
      null;
    }
  }

  return node.tagDef;
}

function getFullyResolvedTagName(path) {
  const parts = [];
  let cur;
  do {
    cur = path.node.name.value;

    if (isAttributeTag(path)) {
      parts.push(cur.slice(1));
    } else {
      parts.push(cur || "*");
      break;
    }
  } while (path = findParentTag(path));

  return parts.reverse().join(":");
}

function findParentTag(path) {
  let cur = path.parentPath;

  while (cur.node) {
    if (cur.isMarkoTagBody()) {
      cur = cur.parentPath;
      continue;
    }

    if (!cur.isMarkoTag()) {
      cur = undefined;
      break;
    }

    if (isTransparentTag(cur)) {
      cur = cur.parentPath;
      continue;
    }

    return cur;
  }
}

function findAttributeTags(path, attributeTags = []) {
  path.get("body.body").forEach((child) => {
    if (isAttributeTag(child)) {
      attributeTags.push(child);
    } else if (isTransparentTag(child)) {
      findAttributeTags(child, attributeTags);
    }
  });

  return attributeTags;
}

function getArgOrSequence(path) {
  const {
    node: { arguments: args } } =
  path;
  const len = args && args.length;

  if (len) {
    if (len > 1) {
      return _compiler.types.sequenceExpression(args);
    } else {
      return args[0];
    }
  }
}

function isLoopTag(path) {
  if (!path.isMarkoTag()) {
    return false;
  }

  const tagName = path.node.name.value;
  return tagName === "while" || tagName === "for";
}

function loadFileForTag(tag) {
  const def = getTagDef(tag);
  const { file } = tag.hub;
  const fs = file.markoOpts.fileSystem;
  const filename = def && def.template;

  if (filename) {
    return file.___getMarkoFile(
    fs.readFileSync(filename).toString("utf-8"),
    createNewFileOpts(file.opts, filename),
    file.markoOpts);

  }
}

function loadFileForImport(file, request) {
  const fs = file.markoOpts.fileSystem;
  const relativeRequest = resolveTagImport(file.path, request);

  if (relativeRequest) {
    const filename =
    relativeRequest[0] === "." ?
    (0, _path.resolve)(file.opts.filename, "..", relativeRequest) :
    (0, _resolveFrom.default)((0, _path.dirname)(file.opts.filename), relativeRequest);
    return file.___getMarkoFile(
    fs.readFileSync(filename).toString("utf-8"),
    createNewFileOpts(file.opts, filename),
    file.markoOpts);

  }
}

function getTemplateId(optimize, request) {
  const id = (0, _path.relative)(ROOT, request);

  if (optimize) {
    return (0, _crypto.createHash)("MD5").update(id).digest("base64").slice(0, 8);
  }

  return id;
}

function resolveTagImport(path, request) {
  const {
    hub: { file } } =
  path;
  if (request[0] === "<") {
    const tagName = request.slice(1, -1);
    const tagDef = (0, _taglib.getTagDefForTagName)(file, tagName);
    const tagEntry = tagDef && (tagDef.renderer || tagDef.template);
    const relativePath = tagEntry && (0, _imports.resolveRelativePath)(file, tagEntry);

    if (!relativePath) {
      throw path.buildCodeFrameError(
      `Unable to find entry point for custom tag <${tagName}>.`);

    }

    return relativePath;
  }

  if (request.endsWith(".marko")) {
    return (0, _imports.resolveRelativePath)(file, request);
  }
}

function createNewFileOpts(opts, filename) {
  const sourceFileName = (0, _path.basename)(filename);
  const filenameRelative = (0, _path.relative)(CWD, filename);
  return {
    ...opts,
    filename,
    sourceFileName,
    filenameRelative,
    parserOpts: {
      ...opts.parserOpts,
      sourceFileName },

    generatorOpts: {
      ...opts.generatorOpts,
      filename,
      sourceFileName } };


}