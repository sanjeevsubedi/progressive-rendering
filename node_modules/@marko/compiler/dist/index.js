"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports._clearDefaults = _clearDefaults;exports.compile = compile;exports.compileFile = compileFile;exports.compileFileSync = compileFileSync;exports.compileSync = compileSync;exports.configure = configure;exports.getRuntimeEntryFiles = getRuntimeEntryFiles;exports.types = exports.taglib = void 0;var _types = _interopRequireWildcard(require("./babel-types"));exports.types = _types;
var _path = _interopRequireDefault(require("path"));
var babel = _interopRequireWildcard(require("@babel/core"));
var _pluginTransformModulesCommonjs = _interopRequireDefault(require("@babel/plugin-transform-modules-commonjs"));
var _pluginSyntaxTypescript = _interopRequireDefault(require("@babel/plugin-syntax-typescript"));
var _pluginTransformTypescript = _interopRequireDefault(require("@babel/plugin-transform-typescript"));
var _babelPlugin = _interopRequireDefault(require("./babel-plugin"));
var _config = _interopRequireDefault(require("./config"));
var taglib = _interopRequireWildcard(require("./taglib"));exports.taglib = taglib;
var _shouldOptimize = _interopRequireDefault(require("./util/should-optimize"));
var _tryLoadTranslator = _interopRequireDefault(require("./util/try-load-translator"));function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function (nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}


let globalConfig = { ..._config.default };
function configure(newConfig) {
  globalConfig = { ..._config.default, ...newConfig };
}

async function compile(src, filename, config) {
  const babelConfig = loadBabelConfig(filename, config);
  const babelResult = await babel.transformAsync(src, babelConfig);
  scheduleDefaultClear(config);
  return buildResult(babelResult);
}

function compileSync(src, filename, config) {
  const babelConfig = loadBabelConfig(filename, config);
  const babelResult = babel.transformSync(src, babelConfig);
  scheduleDefaultClear(config);
  return buildResult(babelResult);
}

async function compileFile(filename, config) {
  return new Promise((resolve, reject) => {
    getFs(config).readFile(filename, "utf-8", (err, src) => {
      if (err) {
        return reject(err);
      }

      return resolve(compile(src, filename, config));
    });
  });
}

function compileFileSync(filename, config) {
  const src = getFs(config).readFileSync(filename, "utf-8");
  return compileSync(src, filename, config);
}

function getRuntimeEntryFiles(output, requestedTranslator) {
  const translator = (0, _tryLoadTranslator.default)(requestedTranslator);
  if (translator && translator.getRuntimeEntryFiles) {
    return translator.getRuntimeEntryFiles(output, (0, _shouldOptimize.default)());
  }

  return [];
}

function loadBabelConfig(filename, config) {
  const markoConfig = { ...globalConfig, ...config, babelConfig: undefined };

  if (markoConfig.stripTypes === undefined) {
    markoConfig.stripTypes =
    markoConfig.output !== "source" && markoConfig.output !== "migrate";
  }

  const requiredPlugins = [
  [_babelPlugin.default, markoConfig],
  [
  markoConfig.stripTypes ? _pluginTransformTypescript.default : _pluginSyntaxTypescript.default,
  {
    isTSX: false,
    allowNamespaces: true,
    optimizeConstEnums: true,
    onlyRemoveTypeImports: true,
    disallowAmbiguousJSXLike: false }]];



  const baseBabelConfig = {
    filenameRelative: filename ?
    _path.default.relative(process.cwd(), filename) :
    undefined,
    sourceFileName: filename ? _path.default.basename(filename) : undefined,
    ...(config && config.babelConfig),
    filename,
    sourceType: "module",
    sourceMaps: markoConfig.sourceMaps,
    code: markoConfig.code,
    ast: markoConfig.ast };


  if (markoConfig.modules === "cjs") {
    requiredPlugins.push([_pluginTransformModulesCommonjs.default, { loose: true }]);
  }

  baseBabelConfig.plugins = requiredPlugins.concat(
  baseBabelConfig.plugins || []);


  return babel.loadPartialConfig(baseBabelConfig).options;
}

function buildResult(babelResult) {
  const {
    ast,
    map,
    code,
    metadata: { marko: meta } } =
  babelResult;
  return { ast, map, code, meta };
}

let clearingDefaultCache = false;
function scheduleDefaultClear(config) {
  if (
  !clearingDefaultCache && (
  clearingDefaultCache = isDefaultCache(config)))
  {
    setImmediate(_clearDefaults);
  }
}

function _clearDefaults() {
  clearingDefaultCache = false;
  globalConfig.cache.clear();
}

function isDefaultCache(config) {
  return !config.cache || config.cache === globalConfig.cache;
}

function getFs(config) {
  return config.fileSystem || globalConfig.fileSystem;
}